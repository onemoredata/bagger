<?xml version="1.0" encoding="UTF-8" ?>
<!-- $Header: /cvsroot/autodoc/autodoc/xml.tmpl,v 1.3 2012/01/05 15:22:28 rbt Exp $ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % myent SYSTEM "entities.ent">
%myent;
]>
<book id="database.lenkwerk" xreflabel="lenkwerk database schema"><title>lenkwerk Model</title>




  <chapter id="public.schema"
           xreflabel="public">
    <title>Schema public</title>
    <para>standard public schema</para>




  </chapter>

  <chapter id="storage.schema"
           xreflabel="storage">
    <title>Schema storage</title>
    <para></para>


      <section id="storage.table.config"
               xreflabel="storage.config">
        <title id="storage.table.config-title">
         Table:
         <database class="view">config</database>
         
        </title>
 

        <para>
           This table stores configuration for the storage nodes.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <database class="table">config</database>
            </title>


            <varlistentry>
              <term><database class="field">id</database></term>
              <listitem><para>
                <database class="datatype">serial</database>




                <database class="constraint">UNIQUE</database>




                <database class="constraint">NOT NULL</database>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">key</database></term>
              <listitem><para>
                <database class="datatype">text</database>


                <database class="constraint">PRIMARY KEY</database>












              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">value</database></term>
              <listitem><para>
                <database class="datatype">json</database>



                <database class="constraint">NOT NULL</database>





              </para>

              <para> JSON is selected here because it is richer than plain text and serialization
libraries are available in all major languages.</para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="storage.table.dimensions"
               xreflabel="storage.dimensions">
        <title id="storage.table.dimensions-title">
         Table:
         <database class="view">dimensions</database>
         
        </title>
 

        <para>
           This contains the partitions by which data is partitioned. Default values
can be set using the default_val field though this is not yet supported.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <database class="table">dimensions</database>
            </title>


            <varlistentry>
              <term><database class="field">id</database></term>
              <listitem><para>
                <database class="datatype">serial</database>




                <database class="constraint">UNIQUE</database>




                <database class="constraint">NOT NULL</database>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">ordinality</database></term>
              <listitem><para>
                <database class="datatype">integer</database>




                <database class="constraint">UNIQUE</database>




                <database class="constraint">NOT NULL</database>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">default_val</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>





                <literal>DEFAULT &apos;notexist&apos;::character varying</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">valid_from</database></term>
              <listitem><para>
                <database class="datatype">timestamp without time zone</database>





                <literal>DEFAULT &apos;-infinity&apos;::timestamp without time zone</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">valid_until</database></term>
              <listitem><para>
                <database class="datatype">timestamp without time zone</database>





                <literal>DEFAULT &apos;infinity&apos;::timestamp without time zone</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">fieldname</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>


                <database class="constraint">PRIMARY KEY</database>












              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="storage.table.index-fields"
               xreflabel="storage.index_fields">
        <title id="storage.table.index-fields-title">
         Table:
         <database class="view">index_fields</database>
         
        </title>
 

        <para>
          Stores the index fields or expressions.

Some care needs to be paid as to the nature of the contents of this table
because while naive SQL injection is not possile at index creation time,
indexes can perform arbitrary code at insert or update time.

For this reason registering indexes is a privileged operation.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <database class="table">index_fields</database>
            </title>


            <varlistentry>
              <term><database class="field">id</database></term>
              <listitem><para>
                <database class="datatype">serial</database>




                <database class="constraint">UNIQUE</database>




                <database class="constraint">NOT NULL</database>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">index_id</database></term>
              <listitem><para>
                <database class="datatype">integer</database>






                <database class="constraint">PRIMARY KEY</database>











                <database class="constraint">REFERENCES <xref linkend="storage.table.indexes"/></database>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">ordinality</database></term>
              <listitem><para>
                <database class="datatype">integer</database>


                <database class="constraint">PRIMARY KEY</database>












              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">expression</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>



                <database class="constraint">NOT NULL</database>





              </para>

              <para>This column has an important security consideration because improper
management of indexes could allow attackers to run arbitrary code during
index update.  The actual CREATE INDEX statement is not vulnerable to
SQL injection attacks itself, but expressions can include function calls
to any function marked immutable.  This means that a clever attacker could
create a function with destructive intent, mark it as immutable and then
call it from a function.

This problem is not actually related to storing the index expressions in
the database.  The problem can happen anywhere these expressions are stored
and therefore it is important to have careful controls on that process.

RECOMMENDATION:  update this table from an infrastructure-as-code framework
only and implement checks to ensure the two are in sync.</para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="storage.table.indexes"
               xreflabel="storage.indexes">
        <title id="storage.table.indexes-title">
         Table:
         <database class="view">indexes</database>
         
        </title>
 

        <para>
           This table includes index definition information for bagger nodes.

This allows us to specify GIN, GIST, btree, and hash indexes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <database class="table">indexes</database>
            </title>


            <varlistentry>
              <term><database class="field">id</database></term>
              <listitem><para>
                <database class="datatype">serial</database>




                <database class="constraint">UNIQUE</database>




                <database class="constraint">NOT NULL</database>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">indexname</database></term>
              <listitem><para>
                <database class="datatype">character varying(16)</database>


                <database class="constraint">PRIMARY KEY</database>








                <literal>DEFAULT &apos;bagger_idx&apos;::character varying</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">access_method</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>



                <database class="constraint">NOT NULL</database>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">tablespc</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>



                <database class="constraint">NOT NULL</database>



                <literal>DEFAULT &apos;pg_default&apos;::character varying</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing storage.index_fields via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="storage.table.index-fields"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="storage.table.postgres-instance"
               xreflabel="storage.postgres_instance">
        <title id="storage.table.postgres-instance-title">
         Table:
         <database class="view">postgres_instance</database>
         
        </title>
 

        <para>
          The postgres_instance table provides enough information for Bagger components 
to connect to the relevant database instances.  Note that authentication is NOT
in scope and must be set separately.  We recommend certificate authentication
or gssapi.  As a fallback, the .pgpass can be used though rotating passwords is
not easy.

DO NOT STORE PASSWORDS IN PLAIN TEXT IN THE DATABASE
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <database class="table">postgres_instance</database>
            </title>


            <varlistentry>
              <term><database class="field">id</database></term>
              <listitem><para>
                <database class="datatype">serial</database>




                <database class="constraint">UNIQUE</database>




                <database class="constraint">NOT NULL</database>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">host</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>


                <database class="constraint">PRIMARY KEY</database>












              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">port</database></term>
              <listitem><para>
                <database class="datatype">integer</database>


                <database class="constraint">PRIMARY KEY</database>












              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">username</database></term>
              <listitem><para>
                <database class="datatype">character varying</database>



                <database class="constraint">NOT NULL</database>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">status</database></term>
              <listitem><para>
                <database class="datatype">smallint</database>



                <database class="constraint">NOT NULL</database>





              </para>

              <para> The status here is a bit string for various statuses.  
Currently the bits are: 
0 - Can read 
1 - Can write

This leads to the following values:
0 - Offline
1 - read-only
2 - write-only
3 - Online (can read and write)

New states may be added in the future.
</para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on postgres_instance</title>

          <varlistentry>
            <term>postgres_instance_status_check</term>
            <listitem><para>CHECK (((status &gt;= 0) AND (status &lt;= 3)))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="storage.table.servermaps"
               xreflabel="storage.servermaps">
        <title id="storage.table.servermaps-title">
         Table:
         <database class="view">servermaps</database>
         
        </title>
 

        <para>
           The servermaps table stores the server maps by generation so that
we can determine which servers are supposed to receive writes together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <database class="table">servermaps</database>
            </title>


            <varlistentry>
              <term><database class="field">generation</database></term>
              <listitem><para>
                <database class="datatype">serial</database>


                <database class="constraint">PRIMARY KEY</database>












              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><database class="field">server_map</database></term>
              <listitem><para>
                <database class="datatype">json</database>



                <database class="constraint">NOT NULL</database>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>



<!-- Function append_dimension(in_fieldname character varying, in_default_val character varying, in_valid_from timestamp without time zone, in_valid_until timestamp without time zone) -->
    <section id="storage.function.append-dimension-in-fieldname-character-varying-in-default-val-character-varying-in-valid-from-timestamp-without-time-zone-in-valid-until-timestamp-without-time-zone"
             xreflabel="()">
      <title id="storage.function.append-dimension-in-fieldname-character-varying-in-default-val-character-varying-in-valid-from-timestamp-without-time-zone-in-valid-until-timestamp-without-time-zone-title">
       append_dimension(in_fieldname character varying, in_default_val character varying, in_valid_from timestamp without time zone, in_valid_until timestamp without time zone)
      </title>
      <titleabbrev id="storage.function.append-dimension-in-fieldname-character-varying-in-default-val-character-varying-in-valid-from-timestamp-without-time-zone-in-valid-until-timestamp-without-time-zone-titleabbrev">
       append_dimension(in_fieldname character varying, in_default_val character varying, in_valid_from timestamp without time zone, in_valid_until timestamp without time zone)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>dimensions</seg>
        </seglistitem>
       </segmentedlist>
 
       This function inserts a named dimension at the end of the list.

It returns the row as saved.

        <programlisting></programlisting>
      </para>
    </section>

<!-- Function append_index_field(in_index_id integer, in_expression character varying) -->
    <section id="storage.function.append-index-field-in-index-id-integer-in-expression-character-varying"
             xreflabel="()">
      <title id="storage.function.append-index-field-in-index-id-integer-in-expression-character-varying-title">
       append_index_field(in_index_id integer, in_expression character varying)
      </title>
      <titleabbrev id="storage.function.append-index-field-in-index-id-integer-in-expression-character-varying-titleabbrev">
       append_index_field(in_index_id integer, in_expression character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>index_fields</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function get_config(in_key text) -->
    <section id="storage.function.get-config-in-key-text"
             xreflabel="()">
      <title id="storage.function.get-config-in-key-text-title">
       get_config(in_key text)
      </title>
      <titleabbrev id="storage.function.get-config-in-key-text-titleabbrev">
       get_config(in_key text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>config</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function get_dimensions() -->
    <section id="storage.function.get-dimensions"
             xreflabel="()">
      <title id="storage.function.get-dimensions-title">
       get_dimensions()
      </title>
      <titleabbrev id="storage.function.get-dimensions-titleabbrev">
       get_dimensions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF dimensions</seg>
        </seglistitem>
       </segmentedlist>
 
        Selects an ordered set of dimensions.  Note that the ordinality is the
order of evaluation for partitioning and all dimensions are evaluated.
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function get_index(in_indexname text) -->
    <section id="storage.function.get-index-in-indexname-text"
             xreflabel="()">
      <title id="storage.function.get-index-in-indexname-text-title">
       get_index(in_indexname text)
      </title>
      <titleabbrev id="storage.function.get-index-in-indexname-text-titleabbrev">
       get_index(in_indexname text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>indexes</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function get_index_fields(in_index_id integer) -->
    <section id="storage.function.get-index-fields-in-index-id-integer"
             xreflabel="()">
      <title id="storage.function.get-index-fields-in-index-id-integer-title">
       get_index_fields(in_index_id integer)
      </title>
      <titleabbrev id="storage.function.get-index-fields-in-index-id-integer-titleabbrev">
       get_index_fields(in_index_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF index_fields</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function get_pg_instance_by_host_and_port(in_host text, in_port integer) -->
    <section id="storage.function.get-pg-instance-by-host-and-port-in-host-text-in-port-integer"
             xreflabel="()">
      <title id="storage.function.get-pg-instance-by-host-and-port-in-host-text-in-port-integer-title">
       get_pg_instance_by_host_and_port(in_host text, in_port integer)
      </title>
      <titleabbrev id="storage.function.get-pg-instance-by-host-and-port-in-host-text-in-port-integer-titleabbrev">
       get_pg_instance_by_host_and_port(in_host text, in_port integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>postgres_instance</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function get_pg_instance_by_id(in_id integer) -->
    <section id="storage.function.get-pg-instance-by-id-in-id-integer"
             xreflabel="()">
      <title id="storage.function.get-pg-instance-by-id-in-id-integer-title">
       get_pg_instance_by_id(in_id integer)
      </title>
      <titleabbrev id="storage.function.get-pg-instance-by-id-in-id-integer-titleabbrev">
       get_pg_instance_by_id(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>postgres_instance</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function insert_dimension(in_ordinality integer, in_fieldname character varying, in_default_val character varying, in_valid_from timestamp without time zone, in_valid_until timestamp without time zone) -->
    <section id="storage.function.insert-dimension-in-ordinality-integer-in-fieldname-character-varying-in-default-val-character-varying-in-valid-from-timestamp-without-time-zone-in-valid-until-timestamp-without-time-zone"
             xreflabel="()">
      <title id="storage.function.insert-dimension-in-ordinality-integer-in-fieldname-character-varying-in-default-val-character-varying-in-valid-from-timestamp-without-time-zone-in-valid-until-timestamp-without-time-zone-title">
       insert_dimension(in_ordinality integer, in_fieldname character varying, in_default_val character varying, in_valid_from timestamp without time zone, in_valid_until timestamp without time zone)
      </title>
      <titleabbrev id="storage.function.insert-dimension-in-ordinality-integer-in-fieldname-character-varying-in-default-val-character-varying-in-valid-from-timestamp-without-time-zone-in-valid-until-timestamp-without-time-zone-titleabbrev">
       insert_dimension(in_ordinality integer, in_fieldname character varying, in_default_val character varying, in_valid_from timestamp without time zone, in_valid_until timestamp without time zone)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>dimensions</seg>
        </seglistitem>
       </segmentedlist>
 
        This function inserts the dimension at the desired place and returns the row
as saved in the database.

The ordinality of all dimensions equal to or greater than the requested
ordinality number are incremented.

        <programlisting></programlisting>
      </para>
    </section>

<!-- Function insert_index_field(in_index_id integer, in_ordinality integer, in_expression character varying) -->
    <section id="storage.function.insert-index-field-in-index-id-integer-in-ordinality-integer-in-expression-character-varying"
             xreflabel="()">
      <title id="storage.function.insert-index-field-in-index-id-integer-in-ordinality-integer-in-expression-character-varying-title">
       insert_index_field(in_index_id integer, in_ordinality integer, in_expression character varying)
      </title>
      <titleabbrev id="storage.function.insert-index-field-in-index-id-integer-in-ordinality-integer-in-expression-character-varying-titleabbrev">
       insert_index_field(in_index_id integer, in_ordinality integer, in_expression character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>index_fields</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function list_pg_instances() -->
    <section id="storage.function.list-pg-instances"
             xreflabel="()">
      <title id="storage.function.list-pg-instances-title">
       list_pg_instances()
      </title>
      <titleabbrev id="storage.function.list-pg-instances-titleabbrev">
       list_pg_instances()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF postgres_instance</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function register_pg_instance(in_host text, in_port integer, in_username text) -->
    <section id="storage.function.register-pg-instance-in-host-text-in-port-integer-in-username-text"
             xreflabel="()">
      <title id="storage.function.register-pg-instance-in-host-text-in-port-integer-in-username-text-title">
       register_pg_instance(in_host text, in_port integer, in_username text)
      </title>
      <titleabbrev id="storage.function.register-pg-instance-in-host-text-in-port-integer-in-username-text-titleabbrev">
       register_pg_instance(in_host text, in_port integer, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>postgres_instance</seg>
        </seglistitem>
       </segmentedlist>
 
       This function registers a new Postgres instance as a storage node.

By design the new node is created offline (state 0).  The arguments are:

 - in_host:      The hostname or IP address of the host.
 - in_port:      The port that this Postgres instance is listening on.
 - in_username:  The username that Schaufel should connect as.


        <programlisting></programlisting>
      </para>
    </section>

<!-- Function save_config(in_key text, in_value json) -->
    <section id="storage.function.save-config-in-key-text-in-value-json"
             xreflabel="()">
      <title id="storage.function.save-config-in-key-text-in-value-json-title">
       save_config(in_key text, in_value json)
      </title>
      <titleabbrev id="storage.function.save-config-in-key-text-in-value-json-titleabbrev">
       save_config(in_key text, in_value json)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>config</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function save_index(in_indexname text, in_access_method text, in_tablespc text) -->
    <section id="storage.function.save-index-in-indexname-text-in-access-method-text-in-tablespc-text"
             xreflabel="()">
      <title id="storage.function.save-index-in-indexname-text-in-access-method-text-in-tablespc-text-title">
       save_index(in_indexname text, in_access_method text, in_tablespc text)
      </title>
      <titleabbrev id="storage.function.save-index-in-indexname-text-in-access-method-text-in-tablespc-text-titleabbrev">
       save_index(in_indexname text, in_access_method text, in_tablespc text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>indexes</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting></programlisting>
      </para>
    </section>

<!-- Function set_pg_instance_status(in_id integer, in_status integer) -->
    <section id="storage.function.set-pg-instance-status-in-id-integer-in-status-integer"
             xreflabel="()">
      <title id="storage.function.set-pg-instance-status-in-id-integer-in-status-integer-title">
       set_pg_instance_status(in_id integer, in_status integer)
      </title>
      <titleabbrev id="storage.function.set-pg-instance-status-in-id-integer-in-status-integer-titleabbrev">
       set_pg_instance_status(in_id integer, in_status integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>postgres_instance</seg>
        </seglistitem>
       </segmentedlist>
 
        This function sets the status of a pg_instance to the value set, returning
a complete database row for the instance as stored if successful.
        <programlisting></programlisting>
      </para>
    </section>

  </chapter>

</book>

